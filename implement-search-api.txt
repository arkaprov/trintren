Step-by-Step Guide to Implement the Search Endpoint

1. GitHub -> settings -> Create new token
2. Clone the NexaDoc Repository - Clone the repository using your GitHub token (classic one -not fine grained)
git clone https://<username>:<token>@github.com/bduswork/bitcoinapps_backend.git
git clone https://arkaprov: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@github.com/WebDev-ASL/NexaDoc.git

3. configure your git identity -  Go to project directory -
git config --global user.email "arka8135@gmail.com"
git config --global user.name "Arka Provo Pal"

4. To avoid disrupting main (production), create a new branch for your task: 
git checkout -b Feature/NEX-112

5. Verify: Run git branch to see * NEXA-112 indicating you’re on that branch.

6. Now i had to install PostgreSQL -> it was already on my system, but i forgot password -> so i run Win + R -> services.msc ->PostgreSQL ->stop
Now go to -> C:\Program Files\PostgreSQL\<version>\data
In the data directory, find pg_hba.conf and open it with a text editor (e.g., Notepad) as Administrator.

# TYPE  DATABASE  USER  ADDRESS  METHOD
local   all       all             md5

Change md5 to trust for local connections (temporary):
local   all       all             trust

7. Now go to /bin and start psql.
pg_ctl -D "C:\Program Files\PostgreSQL\17\data" start
postgres --single -D "C:\Program Files\PostgreSQL\17\data"

You can delete postmaster.pid from /data

ALTER USER arka WITH PASSWORD 'arka123';

net start postgresql-x64-17







pg_ctl -D "C:\Program Files\PostgreSQL\17\data" start    -> server started
psql -U arka -d postgres


Now our project directory, C:\Program Files\PostgreSQL\17\bin -> contains java code, dependencies, but not the database -> we need to setup and manage the database separately.
The application connects to the database via JDBC (as defined in application.yml 

psql -U postgres
ALTER USER postgres WITH PASSWORD 'postgres123';
\q
psql -U postgres
Enter postgres123
CREATE DATABASE nexadoc;
\q.

11. Import NexaDoc into Eclipse

NexaDoc project is built using Gradle rather than Maven
Install Buildship Plugin in Eclipse   -> Go to Help > Eclipse Marketplace, search for "Buildship" -> install

Import the Gradle Project into Eclipse

Open Eclipse.
File > Import > Gradle > Existing Gradle Project > Next.
Click Browse and select C:\Arka\Nexadoc\Nexadoc - 17 Sep 2025\NexaDoc (the directory containing build.gradle).
(Previously my system variables -> java home path was set wrong and i fixed it.

echo %JAVA_HOME%
gradlew build --stacktrace

12. Add Search Endpoint Code

Add files in src/main/java/com/nexalinx/nexadoc (adjust if package differs—check existing structure):

Entity (entity/Document.java): Use code from previous guide.
Repository (repository/DocumentRepository.java): Use code from previous guide.
DTO (dto/DocumentDto.java): Use code from previous guide.
Service (service/DocumentService.java): Use code from previous guide.
Service Impl (service/impl/DocumentServiceImpl.java): Use code from previous guide.
Controller (controller/LandingPageController.java): Use code from previous guide.
Utils: Ensure ResponseType.java, ResponseBuilder.java, Response.java in utils.



13. Run the Application

Right-click NexaDocApplication.java > Run As > Java Application.
Check console for startup on http://localhost:8000.

14. Test in Postman

Install: Download from postman.com.
Request: New > HTTP Request, name "NexaDoc Search".
Configure:

Method: GET.
URL: http://localhost:8000/api/v1/landing-page/search?query=sample.
Params: Key query, Value sample.


Send: Expected response as per guide.
Test Cases: SAMPLE, test, Category, nonexistent, no query.

15. Commit and Push

In Command Prompt (in project directory):
textgit add .
git commit -m "Feature/NEX-112: Implement /api/v1/landing-page/search endpoint"
git push origin Feature/NEX-112
















Step-by-Step Guide
1. Add Search Endpoint Code
You need to create or update several files in the src/main/java/com/nexalinx/nexadoc package (adjust the package name if it differs in your project structure). If these files already exist, modify them accordingly.

Entity (entity/Document.java):
javapackage com.nexalinx.nexadoc.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Entity
@Table(name = "documents")
public class Document extends BaseEntityWithUpdateAndDelete {
    @Column(name = "title", nullable = false)
    private String title;

    @Column(name = "description")
    private String description;

    @Column(name = "category")
    private String category;
}

Ensure BaseEntityWithUpdateAndDelete exists (a parent class with id, createdAt, etc.) or adjust to extend BaseEntity if needed.


Repository (repository/DocumentRepository.java):
javapackage com.nexalinx.nexadoc.repository;

import com.nexalinx.nexadoc.entity.Document;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.List;

public interface DocumentRepository extends JpaRepository<Document, Integer> {
    List<Document> findByTitleContainingIgnoreCaseOrDescriptionContainingIgnoreCaseOrCategoryContainingIgnoreCase(
            String titleQuery, String descriptionQuery, String categoryQuery);
}

DTO (dto/DocumentDto.java):
javapackage com.nexalinx.nexadoc.dto;

import com.nexalinx.nexadoc.entity.Document;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class DocumentDto {
    private Integer id;
    private String title;
    private String description;
    private String category;

    public static DocumentDto from(Document document) {
        DocumentDto dto = new DocumentDto();
        dto.setId(document.getId());
        dto.setTitle(document.getTitle());
        dto.setDescription(document.getDescription());
        dto.setCategory(document.getCategory());
        return dto;
    }
}

Service (service/DocumentService.java):
javapackage com.nexalinx.nexadoc.service;

import com.nexalinx.nexadoc.entity.Document;
import java.util.List;

public interface DocumentService {
    List<Document> searchDocuments(String query);
}

Service Implementation (service/impl/DocumentServiceImpl.java):
javapackage com.nexalinx.nexadoc.service.impl;

import com.nexalinx.nexadoc.entity.Document;
import com.nexalinx.nexadoc.repository.DocumentRepository;
import com.nexalinx.nexadoc.service.DocumentService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
@RequiredArgsConstructor
public class DocumentServiceImpl implements DocumentService {
    private final DocumentRepository documentRepository;

    @Override
    public List<Document> searchDocuments(String query) {
        return documentRepository.findByTitleContainingIgnoreCaseOrDescriptionContainingIgnoreCaseOrCategoryContainingIgnoreCase(
                query, query, query);
    }
}

Controller (controller/LandingPageController.java):
javapackage com.nexalinx.nexadoc.controller;

import com.nexalinx.nexadoc.dto.DocumentDto;
import com.nexalinx.nexadoc.service.DocumentService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.stream.Collectors;

import static com.nexalinx.nexadoc.utils.ResponseBuilder.success;
import static org.springframework.http.ResponseEntity.ok;

@RestController
@RequestMapping("/api/v1/landing-page")
@RequiredArgsConstructor
@Tag(name = "Landing Page", description = "API for landing page operations")
public class LandingPageController {
    private final DocumentService documentService;

    @Operation(summary = "Search documents", description = "Searches documents by title, description, or category using LIKE query.")
    @GetMapping("/search")
    public ResponseEntity<Object> searchDocuments(@RequestParam("query") String query) {
        List<DocumentDto> results = documentService.searchDocuments(query)
                .stream()
                .map(DocumentDto::from)
                .collect(Collectors.toList());
        return ok(success(results, "Documents searched successfully.").getJson());
    }
}

Utils (if not present):

Ensure ResponseType.java, ResponseBuilder.java, and Response.java are in utils. If missing, use:

ResponseType.java:
javapackage com.nexalinx.nexadoc.utils;

public enum ResponseType {
    SUCCESS, ERROR
}

ResponseBuilder.java:
javapackage com.nexalinx.nexadoc.utils;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.Data;

@Data
public class ResponseBuilder {
    private ResponseType status;
    private Object data;
    private String message;

    public static ResponseBuilder success(Object data, String message) {
        ResponseBuilder response = new ResponseBuilder();
        response.setStatus(ResponseType.SUCCESS);
        response.setData(data);
        response.setMessage(message);
        return response;
    }

    public String getJson() {
        try {
            ObjectMapper mapper = new ObjectMapper();
            return mapper.writeValueAsString(this);
        } catch (Exception e) {
            return "{\"status\":\"error\",\"message\":\"Serialization failed\"}";
        }
    }
}

Response.java (optional, if needed):
javapackage com.nexalinx.nexadoc.utils;

public class Response {
    private ResponseType status;
    private Object data;
    private String message;

    // Getters, setters, and constructors as needed
}





Save All Files: Place them in the appropriate packages under src/main/java/com/nexalinx/nexadoc.

2. Run the Application

Ensure the PostgreSQL database (nexadoc) is set up and running (as per earlier steps with psql -U postgres and CREATE DATABASE nexadoc).
In Eclipse, locate NexaDocApplication.java (typically in src/main/java/com/nexalinx/nexadoc).
Right-click the file > Run As > Spring Boot App.

If "Spring Boot App" isn’t an option: Right-click > Run As > Java Application. If it fails, ensure the Spring Boot plugin is active (check Help > Eclipse Marketplace > Search "Spring Tools" and install if needed).


Monitor Console: Look for startup messages like "Started NexaDocApplication in X seconds" and "Tomcat started on port(s): 8000 (http)".
Fix Issues: If it fails (e.g., database connection error), check application.yml (in src/main/resources) for:
yamlserver:
  port: 8000

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/nexadoc
    username: postgres
    password: postgres123  # Update to your password
  jpa:
    hibernate:
      ddl-auto: update
  flyway:
    enabled: true
    locations: classpath:db/migration

Ensure PostgreSQL is running (pg_ctl -D "C:\Program Files\PostgreSQL\17\data" start) and the password matches.



3. Test in Postman

Install Postman (if not installed):

Download from postman.com.
Install and launch.


Create a New Request:

Click New > HTTP Request.
Name it "NexaDoc Search Test".


Configure the Request:

Method: Select GET.
URL: Enter http://localhost:8000/api/v1/landing-page/search?query=sample.
Params Tab:

Key: query
Value: sample


Headers Tab: Leave empty (public endpoint).
Body Tab: None (GET request).


Send the Request:

Click Send.
Expected Response (if data exists):
json{
    "status": "success",
    "data": [
        {"id": 1, "title": "Sample Doc 1", "description": "This is a test", "category": "Category A"},
        {"id": 2, "title": "Sample Doc 2", "description": "Another test", "category": "Category B"}
    ],
    "message": "Documents searched successfully."
}

If No Data: Insert test data via psql:
textpsql -U postgres -d nexadoc
INSERT INTO documents (title, description, category) VALUES
('Sample Doc 1', 'This is a test', 'Category A'),
('Sample Doc 2', 'Another test', 'Category B');
\q



Test Cases:

query=SAMPLE (case-insensitive).
query=test (partial match).
query=Category (category match).
query=nonexistent (empty array).
Omit query (should return 400 Bad Request).


Debug:

If you get a 404, check the console for server errors.
If 500, verify database connectivity and entity mappings.
Save the request to a collection for reuse.



4. Commit and Push Changes

In Eclipse (Git perspective) or Command Prompt:

Navigate to the project:
textcd C:\Arka\Nexadoc\Nexadoc - 17 Sep 2025\NexaDoc

Stage changes:
textgit add .

Commit:
textgit commit -m "Feature/NEX-112: Implement /api/v1/landing-page/search endpoint"

Push:
textgit push origin Feature/NEX-112





Troubleshooting

Code Errors: If classes like BaseEntityWithUpdateAndDelete are missing, create a basic version or adjust Document to extend a simple BaseEntity with an id.
Application Won’t Start: Check the console for exceptions (e.g., DataSource errors—ensure PostgreSQL is running and credentials match).
Postman 404: Confirm the server started on port 8000; adjust server.port in application.yml if needed.
Database Empty: Run the INSERT queries above.




