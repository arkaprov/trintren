Steps to download and install java

1. Search jdk download oracle 
2. https://www.oracle.com/in/java/technologies/downloads/#jdk24-windows
3. Choose x64 installer bin.exe.zip for windows 
The installer contains jre + jdk + development tools.
4. Now in Program files -> Java -> copy unzipped jdk file
5. Copy the bin directory path ->C:\Program Files\Java\jdk-24.0.2\bin
6. Open environment variables. There should be user variable and system variable.
7. You should select user variable ->path variable -> edit -> add one path -> paste our bin path.
8. now run java -version in command -> you should see the version now.


Steps to download and install eclipse

1. Search eclipse jee
2. Download x86_64 for windows.
install ->https://www.eclipse.org/downloads/download.php?file=/oomph/epp/2025-09/R/eclipse-inst-jre-win64.exe -> choose eclipse ide for enterprise java and web developers ->

Steps to setup thw spring project and Tight Coupling

1. Open-> https://start.spring.io/
2. Project -> Maven  -> Springboot- 3.5.5 -> Project metadata - com.arka.core -> artifact- Spring core concepts -> Packaging - jar -> java - 24 -> (Skip dependencies as of now) -> generate -> download zip -> open that directory with IntelliJ
3. Now go to src/main/java


TIght Coupling 

#In the code you provided, the Person class directly creates an Animal object using Animal animal = new Animal();. This means Person is tightly coupled to the specific Animal class. Tight coupling implies that Person depends heavily on the exact implementation of Animal. Any changes to Animal could directly impact Person, even if you don’t modify Person.java.








Steps to Set Up Dependencies and Configurations in the Project Directory (Springboot) (Didn't work for me, but concepts)

1. Download your springboot project into a directory.
2. Go -> https://adoptium.net/temurin/releases -> and download open jdk.zip for windows into your project directory -> ren C:\path\to\nexadoc\tools\jdk-17.0.2+8 jdk -> Extract the JDK to tools\jdk
3. Now create a Project-Specific Environment Script -> nexadoc\venv.bat ->
@echo off
set JAVA_HOME=%CD%\tools\jdk
set PATH=%JAVA_HOME%\bin;%PATH%
echo Java environment activated for NexaDoc project.

4. This script mimics a Python venv by setting environment variables only for the current Command Prompt session, leaving the system environment unchanged.
5. Go into the project directory and write in terminal->
call venv.bat
java -version

6. This would show if java ins there in the directory or not.
7. Now we gotta setup maven wrapper (Isolated Dependencies) -> The Maven Wrapper ensures Maven runs without a system-wide installation.
8. Now we gotta download Apache Maven bin.zip and unzip it into project directory -> https://maven.apache.org/download.cgi ->download from here -> Extract to C:\path\to\nexadoc\tools\maven
9. Add Maven to the session PATH in venv.bat (set accordingly)
@echo off
set JAVA_HOME=%CD%\tools\jdk\
set MAVEN_HOME=%CD%\tools\maven\apache-maven-3.9.11
set PATH=%JAVA_HOME%\bin;%MAVEN_HOME%\bin;%PATH%
echo Java and Maven environment activated for NexaDoc project.

10. Now  Generate Maven Wrapper -> Go to project directory -> 
call venv.bat
mvn -N wrapper:wrapper















Step-by-Step Guide to Implement the Search Endpoint

1. GitHub -> settings -> Create new token
2. Clone the NexaDoc Repository - Clone the repository using your GitHub token (classic one -not fine grained)
git clone https://<username>:<token>@github.com/bduswork/bitcoinapps_backend.git
git clone https://arkaprov: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@github.com/WebDev-ASL/NexaDoc.git

3. configure your git identity -  Go to project directory -
git config --global user.email "arka8135@gmail.com"
git config --global user.name "Arka Provo Pal"

4. To avoid disrupting main (production), create a new branch for your task: 
git checkout -b Feature/NEX-112

5. Verify: Run git branch to see * NEXA-112 indicating you’re on that branch.

6. Now i had to install PostgreSQL -> it was already on my system, but i forgot password -> so i run Win + R -> services.msc ->PostgreSQL ->stop
Now go to -> C:\Program Files\PostgreSQL\<version>\data
In the data directory, find pg_hba.conf and open it with a text editor (e.g., Notepad) as Administrator.

# TYPE  DATABASE  USER  ADDRESS  METHOD
local   all       all             md5

Change md5 to trust for local connections (temporary):
local   all       all             trust

7. Now go to /bin and start psql.
pg_ctl -D "C:\Program Files\PostgreSQL\17\data" start
postgres --single -D "C:\Program Files\PostgreSQL\17\data"

You can delete postmaster.pid from /data

ALTER USER arka WITH PASSWORD 'arka123';

net start postgresql-x64-17







pg_ctl -D "C:\Program Files\PostgreSQL\17\data" start    -> server started
psql -U arka -d postgres


Now our project directory, C:\Program Files\PostgreSQL\17\bin -> contains java code, dependencies, but not the database -> we need to setup and manage the database separately.
The application connects to the database via JDBC (as defined in application.yml 

psql -U postgres
ALTER USER postgres WITH PASSWORD 'postgres123';
\q
psql -U postgres
Enter postgres123
CREATE DATABASE nexadoc;
\q.

11. Import NexaDoc into Eclipse

NexaDoc project is built using Gradle rather than Maven
Install Buildship Plugin in Eclipse   -> Go to Help > Eclipse Marketplace, search for "Buildship" -> install

Import the Gradle Project into Eclipse

Open Eclipse.
File > Import > Gradle > Existing Gradle Project > Next.
Click Browse and select C:\Arka\Nexadoc\Nexadoc - 17 Sep 2025\NexaDoc (the directory containing build.gradle).

use gradlew, and give jdk path and then build. It should show build successful.

12. Add Search Endpoint Code

Add files in src/main/java/com/nexalinx/nexadoc (adjust if package differs—check existing structure):

Entity (entity/Document.java): Use code from previous guide.
Repository (repository/DocumentRepository.java): Use code from previous guide.
DTO (dto/DocumentDto.java): Use code from previous guide.
Service (service/DocumentService.java): Use code from previous guide.
Service Impl (service/impl/DocumentServiceImpl.java): Use code from previous guide.
Controller (controller/LandingPageController.java): Use code from previous guide.
Utils: Ensure ResponseType.java, ResponseBuilder.java, Response.java in utils.


13. Run the Application

Right-click NexaDocApplication.java > Run As > Java Application.
Check console for startup on http://localhost:8000.

14. Test in Postman

Install: Download from postman.com.
Request: New > HTTP Request, name "NexaDoc Search".
Configure:

Method: GET.
URL: http://localhost:8000/api/v1/landing-page/search?query=sample.
Params: Key query, Value sample.


Send: Expected response as per guide.
Test Cases: SAMPLE, test, Category, nonexistent, no query.

15. Commit and Push

In Command Prompt (in project directory):
textgit add .
git commit -m "Feature/NEX-112: Implement /api/v1/landing-page/search endpoint"
git push origin Feature/NEX-112



















Building and Running Gradle Project from Command Line



After cloning the gradle build springboot project, follow these ->

Ensure the Gradle wrapper is executable (on Unix-like systems):
	chmod +x gradlew
(On Windows, it's gradlew.bat and should work out of the box.)
Clean and build the project:
	./gradlew clean build

This downloads dependencies, compiles, and runs tests.
If it fails here, check the error output. Common issues:

Network problems (try a VPN if behind a proxy).
Java version mismatch (run java -version and compare to build.gradle).
Missing dependencies (e.g., if the project uses Lombok, ensure it's configured).
Fix by editing build.gradle if needed, or search the error message online.




If the build succeeds, run the application:
	./gradlew bootRun

This starts the Spring Boot app. Look for logs saying "Started MainApplication in X seconds" and "Tomcat started on port(s): 8080".
Open a browser and go to http://localhost:8080 (or whatever endpoint your app exposes, like /hello if defined).


Stop the app with Ctrl+C in the terminal.

Alternative if bootRun isn't available (older projects):

Build the JAR: ./gradlew bootJar (or just ./gradlew build).
Run: java -jar build/libs/your-app-name.jar.




















Fixing Eclipse Import Issues


If command-line build works but Eclipse fails, the problem is likely with Eclipse's Gradle integration.

Install Buildship Plugin (Eclipse's official Gradle support):

In Eclipse: Help > Eclipse Marketplace.
Search for "Buildship" and install "Buildship Gradle Integration".
Restart Eclipse.


Import the Project:

File > Import > Gradle > Existing Gradle Project.
Browse to your cloned repo directory and select it.
In the import wizard:

Use "Gradle wrapper" if available (recommended).
If it prompts for Java home, point to your JDK.


Click Finish. Eclipse will run a Gradle build during import.


Troubleshoot Import Failures:

Error: Gradle version incompatibility: Update your project's Gradle wrapper to match Eclipse's supported versions (check gradle/wrapper/gradle-wrapper.properties). Run ./gradlew wrapper --gradle-version=8.10.1 (or latest stable).
Error: Missing dependencies or resolution failures: Run ./gradlew dependencies from command line to diagnose. Add repositories like mavenCentral() to build.gradle if missing.
Error: Java version mismatch: Right-click project > Properties > Java Build Path > Ensure JDK matches project.
Error: Lombok or annotations not recognized: Install Lombok plugin in Eclipse (Help > Eclipse Marketplace > "Lombok").
OutOfMemoryError: Increase Eclipse heap in eclipse.ini (add -Xmx2048m).
Refresh Gradle: Right-click project > Gradle > Refresh Gradle Project.
If still failing, delete .gradle folder in project/user home and re-import.


Run in Eclipse:

Once imported successfully, find MainApplication.java (usually in src/main/java/com/example).
Right-click > Run As > Java Application (or Spring Boot App if plugin detects it).
Access http://localhost:8080 in browser.



Additional Tips

If the project has a settings.gradle or multi-modules, ensure all are imported correctly.
Check application.properties or application.yml for port config (default is 8080; change to server.port=8080 if needed).
If build fails due to specific errors (e.g., proxy, auth), provide the exact error message for more targeted help.
Avoid IDE import if command line works—use VS Code with Java/Gradle extensions for lighter setup.

This should get you running! If issues persist, share the exact build error.



















After cloning app, firebase.json and .env configured, (Since my eclipse build was failing), i tried command line from main project directory


.\gradlew clean
.\gradlew build
.\gradlew bootRun

Interact with it at http://localhost:7000.













After u wrote API endpoints -> go to swagger ui of the backend server. Then to run database:

1. Open pgadmin -> Servers -> Register -> Server
2. Add a New Server:

Open pgAdmin and right-click "Servers" in the left panel, then select "Register > Server".
In the "General" tab, give the server a name (e.g., "NexaDoc DB"). (As in .env file)
In the "Connection" tab, enter:

Host: 62.171.179.61
Port: 5433
Maintenance database: nexadoc
Username: nexadoc
Password: Asl@1234


Click "Save".


Connect and Explore:

Expand the server in the left panel, then navigate to Schemas > nexadoc > Tables to view tables.
Use the "Query Tool" (right-click the server or schema > "Query Tool") to run SQL queries.


Now test it- see table and rows and test the values in Swagger.


###################
Now go to the local project directory and run these commands to push it to the my branch of production repo :

cd "C:\Arka\Nexadoc\Nexadoc - 8 Oct 2025\NexaDoc-develop\NexaDoc-develop"
git init
git remote add origin https://github.com/WebDev-ASL/NexaDoc.git
git checkout -b Feature/NEXA-112
git add your-directory  
	use . to add all files):
git commit -m "Initial commit for Feature/NEXA-112"
git push -u origin Feature/NEXA-112



If push gives error -> remote: Invalid username or token. Password authentication is not supported for Git operations.
fatal: Authentication failed for 'https://github.com/WebDev-ASL/NexaDoc.git/'

Option 1: Use a Personal Access Token (PAT)

Generate a Personal Access Token:

Go to GitHub and sign in.
Click your profile picture (top-right) > Settings > Developer settings > Personal access tokens > Tokens (classic).
Click Generate new token (classic).
Give the token a name (e.g., "NexaDoc Push").
Select scopes: At minimum, check repo (for repository access).
Click Generate token and copy the token (e.g., ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx).


Update Git Credentials:

Option A: Update credentials for this push:
When running the push command, use the PAT as your password:
bashgit push -u origin Feature/NEXA-112

Username: Your GitHub username (e.g., YourUsername).
Password: Paste your PAT (it won't display as you type).


#########################################################







Below is a step-by-step guide with specific Git commands for **Developer1** and **Developer2** working on the same GitHub branch (e.g., `main`).
The commands assume both developers are collaborating on the same branch and aim to avoid conflicts while keeping the workflow smooth.

---

### Initial Setup (Both Developers)
Both developers should have the repository cloned locally and be on the same branch (`main`).

**Developer1**:
```bash
git clone <repository-url>
cd <repository-name>
git checkout main
```

**Developer2**:
```bash
git clone <repository-url>
cd <repository-name>
git checkout main
```

---

### Workflow for Making Changes

#### Step 1: Pull Latest Changes Before Starting Work
Both developers should ensure they have the latest code from the remote branch before making changes.

**Developer1**:
```bash
git pull origin main
```

**Developer2**:
```bash
git pull origin main
```

---

#### Step 2: Make and Commit Changes
Each developer works on their changes, stages them, and commits locally. Use clear commit messages.

**Developer1** (e.g., editing `file1.txt`):
```bash
# Edit file1.txt
git add file1.txt
git commit -m "Developer1: Updated file1.txt with new feature"
```

**Developer2** (e.g., editing `file2.txt`):
```bash
# Edit file2.txt
git add file2.txt
git commit -m "Developer2: Added feature to file2.txt"
```

---

#### Step 3: Push Changes to Remote
After committing, push changes to the remote branch. If both developers push at the same time, one may encounter a conflict.

**Developer1**:
```bash
git push origin main
```

**Developer2** (if Developer1 pushed first):
```bash
git push origin main
# If this fails with a "non-fast-forward" error, proceed to Step 4
```

---

#### Step 4: Handle Merge Conflicts
If **Developer2**’s push fails due to Developer1’s changes, they need to pull and resolve conflicts.

**Developer2**:
```bash
git pull origin main
# If conflicts occur, Git will pause the merge and mark conflicts in files
# Open conflicted files (e.g., file1.txt), resolve conflicts manually, then:
git add <conflicted-file>
git commit  # No -m needed; Git uses default merge message
git push origin main
```

**Developer1** (if they need to pull after Developer2 pushes):
```bash
git pull origin main
# Resolve conflicts if any, then:
git add <conflicted-file>
git commit
git push origin main
```

---

#### Step 5: Optional - Using Feature Branches (Recommended)
To avoid direct conflicts on `main`, each developer can work on a temporary feature branch and use pull requests (PRs).

**Developer1** (creates a feature branch):
```bash
git checkout -b feature/dev1-changes
# Edit files, e.g., file1.txt
git add file1.txt
git commit -m "Developer1: Added feature to file1.txt"
git push origin feature/dev1-changes
```

**Developer2** (creates a feature branch):
```bash
git checkout -b feature/dev2-changes
# Edit files, e.g., file2.txt
git add file2.txt
git commit -m "Developer2: Added feature to file2.txt"
git push origin feature/dev2-changes
```

- Both developers create pull requests on GitHub to merge `feature/dev1-changes` and `feature/dev2-changes` into `main`.
- After review, merge the PRs via GitHub’s interface.

**Developer1** (syncs local `main` after PR merge):
```bash
git checkout main
git pull origin main
```

**Developer2** (syncs local `main` after PR merge):
```bash
git checkout main
git pull origin main
```

---

### Best Practices with Commands
- **Sync Frequently**:
  - Before starting work: `git pull origin main`
  - After committing: `git push origin main`
- **Check Status**: Use `git status` to verify your working directory state.
  - **Developer1**: `git status`
  - **Developer2**: `git status`
- **Communicate**: Coordinate via chat or GitHub issues to avoid editing the same files.
- **Clean Up Feature Branches** (after merging PRs):
  - **Developer1**: `git branch -d feature/dev1-changes`
  - **Developer2**: `git branch -d feature/dev2-changes`
  - Delete remote branch: `git push origin --delete feature/dev1-changes`

---

### Notes
- **Avoid Conflicts**: If both developers edit the same lines in the same file, conflicts are more likely. Communicate to assign distinct files or sections.
- **Branch Protection**: If possible, enable GitHub branch protection for `main` to require PRs, preventing direct pushes.
- **Test Changes**: Run tests (e.g., `npm test` or equivalent) before committing to ensure code integrity.

This workflow ensures **Developer1** and **Developer2** can collaborate effectively on the same branch while minimizing conflicts. Using feature branches with PRs is strongly recommended for cleaner collaboration.


##############################################################################################



















### Steps to Create and Merge the Pull Request



It looks like you’ve pushed your changes to the `Feature/NEXA-112` branch of the `NexaDoc` repository, but you’re now facing a situation where you need to merge a pull request (PR).
I’ll guide you through the steps to create and merge a PR for your branch, assuming you’re using GitHub. I’ll also address potential issues and provide clear instructions.




1. **Verify the Push**  
   First, ensure your changes were successfully pushed to the `Feature/NEXA-112` branch:
   ```bash
   git push origin Feature/NEXA-112
   ```
   If you already ran `git push -u origin Feature/NEXA-112`, this step may not be necessary unless you made additional changes. Check the repository on GitHub (`https://github.com/WebDev-ASL/NexaDoc`) to confirm your branch exists.

2. **Create a Pull Request**  
   - Go to the GitHub repository: `https://github.com/WebDev-ASL/NexaDoc`.
   - You should see a prompt indicating that `Feature/NEXA-112` was recently pushed. Click **Compare & pull request**. If you don’t see this, navigate to the **Pull Requests** tab and click **New Pull Request**.
   - Set the base branch (e.g., `main`, `develop`, or `production`) and the compare branch (`Feature/NEXA-112`).
   - Add a title (e.g., `Feature/NEXA-112: Initial Implementation`) and a description for the PR, referencing the ticket (e.g., `Implements NEXA-112`).
   - Click **Create Pull Request**.

3. **Handle Merge Conflicts (If Any)**  
   If GitHub indicates merge conflicts:
   - Pull the latest changes from the base branch (e.g., `production`):
     ```bash
     cd "C:\Arka\Nexadoc\Nexadoc - 8 Oct 2025\NexaDoc-develop\NexaDoc-develop"
     git fetch origin
     git checkout Feature/NEXA-112
     git merge origin/production
     ```
   - If conflicts arise, Git will pause and list conflicting files. Open these files in your editor, resolve conflicts (look for `<<<<<<<`, `=======`, `>>>>>>>` markers), and mark them as resolved:
     ```bash
     git add <resolved-file>
     git commit
     git push origin Feature/NEXA-112
     ```
   - Refresh the PR on GitHub; the conflicts should be resolved.

4. **Request Review and Merge**  
   - Assign reviewers or notify your team (per your project’s workflow).
   - Once approved, merge the PR:
     - On GitHub, select the merge option (e.g., **Merge without squash**, **Squash and merge**, or **Rebase and merge**) based on your team’s conventions.
     - Click **Confirm Merge**.
     - Optionally, delete the `Feature/NEXA-112` branch after merging.

5. **Sync Your Local Repository**  
   After merging, update your local repository:
   ```bash
   git checkout production
   git pull origin production
   ```

### Notes and Potential Issues
- **Existing Repository**: If the directory was already a Git repository, `git init` may not be necessary and could cause issues. If you see unexpected behavior, check if a `.git` folder already exists:
  ```bash
  dir .git
  ```
  If it exists, skip `git init` and proceed with the other commands.

- **Remote Already Added**: If `git remote add origin` fails with “remote origin already exists,” verify the remote:
  ```bash
  git remote -v
  ```
  If it’s correct, skip the `git remote add` step. If incorrect, update it:
  ```bash
  git remote set-url origin https://github.com/WebDev-ASL/NexaDoc.git
  ```

- **Branch Already Exists**: If `Feature/NEXA-112` already exists remotely, `git checkout -b` will fail. Instead, switch to it:
  ```bash
  git checkout Feature/NEXA-112
  ```

- **Authentication Issues**: If `git push` fails due to authentication, ensure you have access to the repository. Use a personal access token or SSH key if prompted. For HTTPS:
  ```bash
  git push -u origin Feature/NEXA-112
  ```
  Enter your GitHub username and a personal access token (not your password).

- **Adding Files**: You mentioned `git add your-directory`. If you meant to add all files, use:
  ```bash
  git add .
  ```
  If you only want to add specific files or directories, replace `your-directory` with the actual path (e.g., `git add src/`).

- **Permissions**: Ensure you have permission to push to `Feature/NEXA-112` and merge PRs into the target branch. If not, contact your repository admin.

### Example Workflow Recap
Assuming no conflicts and a clean setup:
```bash
cd "C:\Arka\Nexadoc\Nexadoc - 8 Oct 2025\NexaDoc-develop\NexaDoc-develop"
git checkout -b Feature/NEXA-112
git add .
git commit -m "Initial commit for Feature/NEXA-112"
git push -u origin Feature/NEXA-112
```
Then create and merge the PR via GitHub.

### If You Need Further Help
- If you encounter specific errors (e.g., merge conflicts, push failures), share the error message, and I’ll provide targeted guidance.
- If you want to confirm the PR’s status, check `https://github.com/WebDev-ASL/NexaDoc/pulls`.
- If you prefer automating PR creation via CLI, consider using the `gh` (GitHub CLI) tool:
  ```bash
  gh pr create --base production --head Feature/NEXA-112 --title "Feature/NEXA-112" --body "Implements NEXA-112"
  ```

Let me know if you hit any issues or need clarification!
